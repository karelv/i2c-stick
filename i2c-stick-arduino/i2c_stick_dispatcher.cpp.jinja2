// this file is automatically generated:
// please edit 'context.yaml', and then:
// run the python doit script `python dodo.py generate` or `doit generate`.

#include "i2c_stick_dispatcher.h"
#include "i2c_stick.h"
#include "i2c_stick_cmd.h"

// Include all the drivers cmd header files:
{%- for driver in drivers %}
#include "{{driver.src_name}}_cmd.h"
{%- endfor %}

// Include all the applications header files:
{%- for app in applications %}
#include "{{app.src_name}}_app.h"
{%- endfor %}

#include <string.h>
#include <stdlib.h>

int16_t 
i2c_stick_register_all_drivers()
{
  int16_t result = 1;
{%- for driver in drivers %}
  if (cmd_{{driver.function_id}}_register_driver() < 0) result = -1;
{%- endfor %}
  return result;
}


const char*
i2c_stick_get_drv_name_by_drv(uint8_t drv)
{
  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      return DRV_{{driver.name}}_NAME;
{%- endfor %}
    default:
      if (0) {}
  }
  return "Unknown";
}


uint8_t
i2c_stick_get_drv_by_drv_name(const char *drv_name)
{
{%- for driver in drivers %}
  if (!strcasecmp(drv_name, DRV_{{driver.name}}_NAME)) return DRV_{{driver.name}}_ID;
{%- endfor %}
  return 0;
}


const char*
i2c_stick_get_app_name(uint8_t app_id)
{
  switch(app_id)
  {
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      return APP_{{app.name}}_NAME;
{%- endfor %}
    default:
      if (app_id) {}
  }
  return "Unassigned";
}


uint8_t
i2c_stick_get_app_id(const char *app_name)
{
{%- for app in applications %}
  if (!strcasecmp(app_name, APP_{{app.name}}_NAME)) return APP_{{app.name}}_ID;
{%- endfor %}
  return APP_NONE;
}


// command functions.

uint8_t
cmd_mv(uint8_t sa, float *mv_list, uint16_t *mv_count, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_mv(sa, mv_list, mv_count, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_raw(uint8_t sa, uint16_t *raw_list, uint16_t *raw_count, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_raw(sa, raw_list, raw_count, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_nd(uint8_t sa, uint8_t *nd, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_nd(sa, nd, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_sn(uint8_t sa, uint16_t *sn_list, uint16_t *sn_count, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_sn(sa, sn_list, sn_count, error_message);
      break;
{%- endfor %}
    default:
      *sn_count = 0;
      return 0;
  }
  return drv;
}


uint8_t
cmd_cs(uint8_t sa, uint8_t channel_mask, const char *input)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;
  uint8_t raw = g_sa_drv_register[spot].raw_;

  char buf[16]; memset(buf, 0, sizeof(buf));

  send_answer_chunk(channel_mask, "cs:", 0);
  uint8_to_hex(buf, sa);
  send_answer_chunk(channel_mask, buf, 0);
  send_answer_chunk(channel_mask, ":RAW=", 0);
  itoa(raw, buf, 10);
  send_answer_chunk(channel_mask, buf, 1);

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_cs(sa, channel_mask, input);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_cs_write(uint8_t sa, uint8_t channel_mask, const char *input)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  char buf[16]; memset(buf, 0, sizeof(buf));

  const char *var_name = "RAW=";
  if (!strncmp(var_name, input, strlen(var_name)))
  {
    // 1.1. try to find if the desired value is a 'driver-name'
    int16_t value = atoi(input+strlen(var_name));
    if ((value >= 0) && (value <= 1))
    {
      if (value == 1)
      {
        g_sa_drv_register[spot].raw_ = 1;
      } else
      {
        g_sa_drv_register[spot].raw_ = 0;
      }
      send_answer_chunk(channel_mask, "+cs:", 0);
      uint8_to_hex(buf, sa);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":RAW=", 0);
      uint8_to_hex(buf, g_sa_drv_register[spot].raw_);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":OK [host-register]", 1);
    } else
    {
      send_answer_chunk(channel_mask, "+cs:", 0);
      uint8_to_hex(buf, sa);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":RAW= FAIL; value not valid", 1);
    }
    return drv;
  }

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_cs_write(sa, channel_mask, input);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_mr(uint8_t sa, uint16_t *mem_list, uint16_t mem_start_address, uint16_t mem_count, uint8_t *bit_per_address, uint8_t *address_increments, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_mr(sa, mem_list, mem_start_address, mem_count, bit_per_address, address_increments, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }

  return drv;
}


uint8_t
cmd_mw(uint8_t sa, uint16_t *mem_list, uint16_t mem_start_address, uint16_t mem_count, uint8_t *bit_per_address, uint8_t *address_increments, char const **error_message)
{
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_mw(sa, mem_list, mem_start_address, mem_count, bit_per_address, address_increments, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }

  return drv;
}


uint8_t
cmd_is(uint8_t sa, uint8_t drv, uint8_t *is_ok, char const **error_message)
{
  if ((drv <= 0) || (drv > 63))
  {
    *is_ok = 0;
    return 0;
  }

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_is(sa, is_ok, error_message);
      break;
{%- endfor %}
    default:
      return 0;
  }

  return drv;
}



uint8_t
cmd_tear_down(uint8_t sa)
{
  if (sa == 255)
  {
    for (sa = 0; sa <= 127; sa++)
    {
      cmd_tear_down(sa);
    }
    return sa;
  }
  // sanity check
  if (sa > 127) { return 0; }

  uint16_t spot = g_sa_list[sa].spot_;
  uint8_t drv = g_sa_drv_register[spot].drv_;

  switch(drv)
  {
{%- for driver in drivers %}
    case DRV_{{driver.name}}_ID:
      cmd_{{driver.function_id}}_tear_down(sa);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return drv;
}


uint8_t
cmd_la(uint8_t channel_mask)
{
  uint8_t count = 0;
  char buf[16]; memset(buf, 0, sizeof(buf));

{%- for app in applications %}
  send_answer_chunk(channel_mask, "la:", 0);
  itoa(APP_{{app.name}}_ID, buf, 10);
  send_answer_chunk(channel_mask, buf, 0);
  send_answer_chunk(channel_mask, ":" APP_{{app.name}}_NAME, 1);
  count++;
{%- endfor %}

  if (count == 0)
  {
    send_answer_chunk(channel_mask, "la:FAILED (no applications registered)", 1);
  }

  return count;
}


uint8_t
cmd_app_begin(uint8_t app_id, uint8_t channel_mask)
{
  char buf[32];
  switch(app_id)
  {
    case APP_NONE:
      send_answer_chunk(channel_mask, ":", 0);
      itoa(APP_NONE, buf, 10);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":OK", 1);
      break;
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      return cmd_{{app.function_id}}_app_begin(channel_mask);
{%- endfor %}
    default:
      send_answer_chunk(channel_mask, ":", 0);
      itoa(app_id, buf, 10);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":FAILED (no registered app id)", 1);
      break;
  }
  return APP_NONE;
}


uint8_t
cmd_app_end(uint8_t channel_mask)
{
  switch(g_app_id)
  {
    case APP_NONE:
      break;
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      cmd_{{app.function_id}}_app_end(channel_mask);
      g_app_id = APP_NONE;
      break;
{%- endfor %}
    default:
      break;
  }
  return APP_NONE;
}


void
handle_applications(uint8_t channel_mask)
{
  switch(g_app_id)
  {
    case APP_NONE:
      break;
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      handle_{{app.function_id}}_app(channel_mask);
      break;
{%- endfor %}
    default:
      break;
  }
}


uint8_t
cmd_ca(uint8_t app_id, uint8_t channel_mask, const char *input)
{
  char buf[16]; memset(buf, 0, sizeof(buf));
  switch(app_id)
  {
    case APP_NONE:
      send_answer_chunk(channel_mask, "ca:", 0);
      itoa(APP_NONE, buf, 10);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":none", 1);
      break;
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      cmd_{{app.function_id}}_ca(channel_mask, input);
      break;
{%- endfor %}
    default:
      send_answer_chunk(channel_mask, "ca:", 0);
      itoa(app_id, buf, 10);
      send_answer_chunk(channel_mask, buf, 0);
      send_answer_chunk(channel_mask, ":FAILED (unregistered app id)", 1);
      return APP_NONE;
  }
  return app_id;
}


uint8_t
cmd_ca_write(uint8_t app_id, uint8_t channel_mask, const char *input)
{
  // 1. all is specific for each application
  switch(app_id)
  {
    case APP_NONE:
      break;
{%- for app in applications %}
    case APP_{{app.name}}_ID:
      cmd_{{app.function_id}}_ca_write(channel_mask, input);
      break;
{%- endfor %}
    default:
      return 0;
  }
  return app_id;
}

