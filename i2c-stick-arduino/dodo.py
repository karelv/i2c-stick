# todo:
# [ ] create package / website within this dodo.py file.
# [ ] align version number of firmware and the python package. (make them one and the same!)
import sys
import subprocess

CONTEXT_FILE = "context.yaml"

DOIT_CONFIG = {'action_string_formatting': 'both',
               'default_tasks': ['arduino-compile:i2c-stick', 'cleaner'],
               }
PIP_USER = " --user "
if sys.prefix != sys.base_prefix:  # check if we are in a virtual environment
    PIP_USER = ""

try:
    import doit
except (Exception,) as e:
    print("installing python packages from requirements.txt")
    t = subprocess.check_output('pip install {} -r requirements.txt'.format(PIP_USER), text=True)
    print(t)
    print("\n\nPlease run this script again")
    print("Note: instead of 'python dodo.py', now you can use 'doit'")
    print("Note: use 'doit list' for a list of commands.")
    exit(1)

import shutil
import os
import yaml
import jinja2
import yamlinclude
from glob import glob
from pathlib import Path
import serial.tools.list_ports
from doit.action import CmdAction
import platform

with open(CONTEXT_FILE) as f:
    context = yaml.load(f, Loader=yaml.FullLoader)

arduino_add_url = " ".join(["--additional-urls {}".format(x) for x in context['board_manager']['additional-urls']])

ARDUINO_CLI = os.path.join('tools', 'arduino-cli'+Path(sys.executable).suffix)


def str_presenter(dumper, data):
    if len(data.splitlines()) > 1:  # check for multiline string
        return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')
    return dumper.represent_scalar('tag:yaml.org,2002:str', data)


yaml.add_representer(str, str_presenter)


def remove(path):
    """ param <path> could either be relative or absolute. """
    for p in glob(path):
        if os.path.isfile(p) or os.path.islink(p):
            os.remove(p)  # remove the file
        elif os.path.isdir(p):
            shutil.rmtree(p)  # remove dir and all contains
        else:
            raise ValueError("path {} is not a file or dir.".format(p))


def task_cleaner():
    """ Clean the entire repository for a git commit & be ready to re-compile the entire project!"""
    def do_clean():
        patterns = ["build",
                    "package",
                    "*~",
                    "*.bak"]
        for pattern in patterns:
            try:
                remove(pattern)
            except Exception as err:
                print(str(err))

        # reset the automatically generated files...
        txt = """
// this file is automatically generated:
// please edit 'context.yaml', and then:
// run the doit command `python dodo.py generate` or `doit generate`.

#error "This file is automatically generated; please run `python dodo.py source` or `doit source` from command line"
"""
        with open("i2c_stick_dispatcher.cpp", "w") as text_file:
            text_file.write(txt)
        with open("i2c_stick_dispatcher.h", "w") as text_file:
            text_file.write(txt)
        from doit.doit_cmd import DoitMain
        DoitMain().run(["forget", "generate:i2c_stick_dispatcher.h"])
        DoitMain().run(["forget", "generate:i2c_stick_dispatcher.cpp"])

    return {
        "actions": None,
        "clean": [do_clean],
    }


def task_pip():
    """Install required python packages using pip"""
    for rqt_file in ['requirements.txt']:
        yield {
            'name': rqt_file,
            'actions': ["pip install {} -r {}".format(PIP_USER, rqt_file)],
            'file_dep': [rqt_file],
        }


def task_arduino_install_cli():
    """Arduino: Install the arduino-cli tool"""
    def do_install(task):
        if not Path("tools").is_dir():
            os.mkdir('tools')
        system = platform.system().lower()
        os_dict = {
            'linux': 'Linux',
            'windows': 'Windows',
            'darwin': 'macOS',
        }
        bits = '32bit'
        if sys.maxsize > 2**32:
            bits = '64bit'
        zip_suffix = 'tar.gz'
        if system == 'windows':
            zip_suffix = 'zip'

        url = "https://downloads.arduino.cc/arduino-cli/arduino-cli_latest_{}_{}.{}".format(os_dict[system], bits, zip_suffix)
        print("downloading:", url)
        import io
        import zipfile
        from contextlib import closing
        import requests

        r = requests.get(url)
        with closing(r), zipfile.ZipFile(io.BytesIO(r.content)) as archive:
            for member in archive.infolist():
                if member.filename == Path(task.targets[0]).name:
                    print("file: {}".format(member.filename))
                    with open(task.targets[0], "wb") as file:
                        file.write(archive.read(member))

        return

    return {
        'basename': 'arduino-install-cli',
        'actions': [(do_install, )],
        'verbosity': 2,
        'file_dep': ['requirements.txt'],
        'targets': [ARDUINO_CLI],
    }


def task_package():
    """Create the ZIP package file"""

    def do_package():
        shutil.copy('firmware_list.md', 'build')
        # remove("package")
        # os.mkdir("package")
        # dst = os.path.join("package", "ktc_trial")
        # os.mkdir(dst)
        # shutil.copy(os.path.join("dist", 'ktc_trial.exe'), dst)
        # shutil.copy("ktc_trial.yml", dst)
        # shutil.make_archive("ktc_trial", 'zip', "package")
        return

    return {
        'actions': [do_package],
        # 'targets': ['ktc_trial.zip'],
        'clean': True,
        # 'file_dep': ['ktc_trial.yml', os.path.join("dist", 'ktc_trial.exe')],
        'task_dep': ['arduino-compile', 'generate:firmware_list.md'],
    }


def task_arduino_update_boards():
    """Arduino: get a fresh copy of the board index"""
    return {
        'basename': 'arduino-update-boards',
        'actions': ["{} {} core update-index".format(ARDUINO_CLI, arduino_add_url),
                    ],
        'file_dep': [CONTEXT_FILE],
        'task_dep': ['arduino-install-cli'],
    }


def task_arduino_install_board():
    """Arduino: install the board tool-chain"""
    for board in context['board_manager']['boards']:
        yield {
            'basename': 'arduino-install-board',
            'name': board,
            'actions': ["{} {} core install {}".format(ARDUINO_CLI, arduino_add_url, board),
                        ],
            'task_dep': ['arduino-install-cli', 'arduino-update-boards'],
            'file_dep': [CONTEXT_FILE],
        }


def task_arduino_install_libs():
    """Arduino: install the specific libraries"""
    return {
        'basename': 'arduino-install-libs',
        "actions": None,
        'task_dep': ['arduino-install-cli'],
    }


def task_arduino_compile():
    """Arduino: Compile the sources into a UF2 file (and bin-file)"""
    working_directory = Path('.')
    headers = list(working_directory.glob('*.h'))
    cpp_files = list(working_directory.glob('*.cpp'))
    for board in context['boards']:
        yield {
            'basename': 'arduino-compile',
            'name': board['nick'],
            'actions': ["{} compile --fqbn {} i2c-stick-arduino.ino -e --clean".format(ARDUINO_CLI, board['fqbn']),
                        ],
            'task_dep': ['arduino-install-cli',
                         'arduino-install-board:'+board['platform'],
                         'arduino-install-libs',
                         'generate:i2c_stick_dispatcher.h',
                         'generate:i2c_stick_dispatcher.cpp',
                        ],
            'file_dep': [CONTEXT_FILE,
                         'i2c-stick-arduino.ino',
                         'i2c_stick_dispatcher.h',
                         'i2c_stick_dispatcher.cpp'] + headers + cpp_files,
            'targets': ['build/{}/i2c-stick-arduino.ino.uf2'.format(board['fqbn'].replace(":", "."))],
        }


def task_arduino_upload():
    """Arduino: Upload to the target board"""
    def do_upload(board_cfg, port):
        if port == 'auto':
            filtered_ports = []
            pid = None
            vid = None
            if 'USB_VID' in board_cfg:
                vid = board_cfg['USB_VID']
            if 'USB_PID' in board_cfg:
                pid = board_cfg['USB_PID']
            for p in serial.tools.list_ports.comports(include_links=False):
                if vid is None:
                    if pid is None:
                        filtered_ports.append(p)
                        continue

                if vid is None:
                    if p.pid == pid:
                        filtered_ports.append(p)
                        continue
                if pid is None:
                    if p.vid == vid:
                        filtered_ports.append(p)
                        continue

                if p.vid == vid:
                    if p.pid == pid:
                        filtered_ports.append(p)
            port = filtered_ports[0].name
        return "{} upload --fqbn {} i2c-stick-arduino.ino --port {}".format(ARDUINO_CLI, board_cfg['fqbn'], port)

    for board in context['boards']:
        yield {
            'basename': 'arduino-upload',
            'name': board['nick'],
            'params': [
                {'name': 'port',
                 'short': 'p',
                 'long': 'port',
                 'type': str,
                 'default': 'auto',
                 },
            ],
            'actions': [CmdAction((do_upload, [board], {})),
                        ],
            'task_dep': ['arduino-install-cli',
                         'arduino-compile',
                        ],
            'file_dep': [CONTEXT_FILE],
            'uptodate': [False],  # force to run the task always
            'verbosity': 2,
        }


def task_generate():
    """Generate file using context.yaml and jinja2 template files"""
    def do_generate(template, output):
        this_dir = os.path.dirname(os.path.abspath(__file__))
        yamlinclude.YamlIncludeConstructor.add_to_loader_class(loader_class=yaml.FullLoader, base_dir=this_dir)
        loader = jinja2.FileSystemLoader(this_dir)

        env = jinja2.Environment(
            loader=loader,
            autoescape=jinja2.select_autoescape()
        )

        t = env.get_template(template)

        with open(output, 'w') as output_f:
            output_f.write(t.render(context))

    working_directory = Path('.')
    for jinja2_file in working_directory.glob('*.jinja2'):
        if jinja2_file.with_suffix('').with_suffix('').name.endswith('driver_cmd'):
            continue
        output_file = jinja2_file.with_suffix('')
        yield {
            'name': output_file.name,
            'actions': [(do_generate, [jinja2_file.name, output_file.name])],
            'file_dep': [jinja2_file.name],
            'task_dep': ['pip:requirements.txt'],
            'targets': [output_file.name],
        }


def task_add_driver():
    """Add a templated entry for a new sensor to the framework"""
    def do_generate(template, output, data):
        this_dir = os.path.dirname(os.path.abspath(__file__))
        yamlinclude.YamlIncludeConstructor.add_to_loader_class(loader_class=yaml.FullLoader, base_dir=this_dir)
        loader = jinja2.FileSystemLoader(this_dir)

        env = jinja2.Environment(
            loader=loader,
            autoescape=jinja2.select_autoescape()
        )

        t = env.get_template(template)
        print("output:", output)
        with open(output, 'w') as output_f:
            output_f.write(t.render(data))
            output_f.write("\n")

    def do_add_driver(driver, src_name, function_id, sa_list):
        if driver is None:
            print("Please provide parameters about the drivers")
            print("Run 'doit info add-driver' for more information")
            return
        if src_name is None:
            src_name = driver.lower()
        if function_id is None:
            if src_name.startswith('mlx'):
                function_id = src_name[3:]
        if function_id is None:
            print("Please provide parameters about the drivers")
            print("Run 'doit info add-driver' for more information")
            return
        if len(sa_list) == 0:
            print("Please provide parameters about the drivers")
            print("Run 'doit info add-driver' for more information")
            return

        driver_data = { 'driver': {
                'name': driver,
                'src_name': src_name,
                'function_id': function_id,
                'sa_list': sa_list,
            },
        }

        driver_ids = [x['id'] for x in context['drivers']]
        for drv in context['drivers']:
            if drv['name'] == driver:
                print("ERROR: Driver '{}' already exists; edit the file 'context.yaml' manually to resolve this issue".format(driver))
                return

        do_generate("driver_cmd.h.jinja2", "{}_cmd.h".format(src_name), driver_data)
        do_generate("driver_cmd.cpp.jinja2", "{}_cmd.cpp".format(src_name), driver_data)
        # now update the context.yaml file!

        context['drivers'].append({
            'id': max(driver_ids)+1,
            'name': driver,
            'scr_name': src_name,
            'function_id': function_id,
        })
        with open(CONTEXT_FILE, 'w') as output_f:
            output_f.write(yaml.dump(context))
            output_f.write("\n")

        # and finally re-generate the dispatcher for the newly added driver.
        from doit.doit_cmd import DoitMain
        DoitMain().run(["--always", "generate:i2c_stick_dispatcher.h"])
        DoitMain().run(["--always", "generate:i2c_stick_dispatcher.cpp"])

    return {
        'basename': 'add-driver',
        'actions': [(do_add_driver,)],
        'file_dep': ['driver_cmd.h.jinja2'],
        'params': [
            {'name': 'driver',
             'short': 'd',
             'long': 'driver',
             'type': str,
             'default': None,
             },
            {'name': 'src_name',
             'short': 's',
             'long': 'src_name',
             'type': str,
             'default': None,
             },
            {'name': 'function_id',
             'short': 'f',
             'long': 'function_id',
             'type': str,
             'default': None,
             },
            {'name': 'sa_list',
             'short': 'a',
             'long': 'sa',
             'type': list,
             'default': [],
             },
        ],
        'uptodate': [False],  # make to run the task always
        'verbosity': 2,
    }


if __name__ == '__main__':
    import doit
    doit.run(globals())
